Файл 1
1)(= 2 (+ 1 1))
2)(= (+ 3 4) 7 (+ 2 5))
3)(= true (= 2 2/1))
4)(= false (= 2 2.0))
5)(= true (== 2.0 2))
6)(= true (not (= 1 nil)))
7)(= false (= "hello" :hello 'hello))
8)(= :hello (keyword :hello))
9)(= 'hello (symbol 'hello))
10)(= (keyword nil) nil)
11)(not= :fill-in-the-blank :fill)
Файл 2
1)(= "hello" "hello")
2)(= "world" (str 'world))
3)(= "Cool right?" (str "Cool " "right?"))
4)(= \C (get "Characters" 0))
5)(= 11 (count "Hello World"))
6)(= false (= \c "c"))
7)(= "World" (subs "Hello World" 6 11))
8)(= "123" (clojure.string/join '(1 2 3)))
9)(= "1, 2, 3" (clojure.string/join ", " '(1 2 3)))
10)(= "olleh" (clojure.string/reverse "hello"))
11)(= 0 (clojure.string/index-of "hello world" "h"))
12)(= 13 (clojure.string/last-index-of "hello world, hello" "hello"))
13)(= nil (clojure.string/index-of "hello world" "bob"))
14)(= "hello world" (clojure.string/trim "  \nhello world \t \n"))
15)user=> (= true (char? \c))
16)(= false (char? "a"))
17)(= false (string? \b))
18)(= true (string? "a"))
19)(= true (clojure.string/blank? ""))
20)(= true (clojure.string/blank? " \n \t  "))
21)(= false (clojure.string/blank? "hello?\nare you out there?"))
Файл 3
1)(= '(1 2 3 4 5) (list 1 2 3 4 5))
2)(= 1 (first '(1 2 3 4 5)))
3)(= '(2 3 4 5) (rest '(1 2 3 4 5)))
4)(= 3 (count '(dracula dooku chocula)))
5)(= 0 (count '()))
6)(= '() (rest '(100)))
7)(= '(:a :b :c :d :e) (cons :a '(:b :c :d :e)))
8)(= '(:e :a :b :c :d) (conj '(:a :b :c :d) :e))
9) (= :a (peek '(:a :b :c :d :e)))
10)(= '(:b :c :d :e) (pop '(:a :b :c :d :e)))
11)(= "No dice!" (try
          (pop '())
          (catch IllegalStateException e
            "No dice!")))
12)(= '() (try
          (rest '())
          (catch IllegalStateException e
            "No dice!")))
Файл 4
1)(= 1 (count [42]))
2)(= '(1) (vec '(1)))
3)(= [nil nil] (vector nil nil))
4)(= [1 2] (vec '(1 2)))
5)(= [111 222 333] (conj [111 222] 333))
6)(= :peanut (first [:peanut :butter :and :jelly]))
7)(= :jelly (last [:peanut :butter :and :jelly]))
8)(= :jelly (nth [:peanut :butter :and :jelly] 3))
9)(= [:butter :and] (subvec [:peanut :butter :and :jelly] 1 3))
10)(= (list 1 2 3) (vector 1 2 3))
Файл 5
(ns your-namespace
  (:require [clojure.set :as set]))

1)(= #{3} (set '(3)))
2)(= 3 (count #{1 2 3}))
3)(= #{1 2 3 4 5} (set '(1 1 2 2 3 3 4 4 5 5)))
4)(= #{1 2 3 4 5} (set/union #{1 2 3 4} #{2 3 5}))
5)(= #{2 3} (set/intersection #{1 2 3 4} #{2 3 5}))
6)(= #{1 4} (set/difference #{1 2 3 4 5} #{2 3 5}))
Файл 6
(ns koans.06-maps
  (:require [koan-engine.core :refer :all]))

  1)(= {:a 1 :b 2} (hash-map :a 1 :b 2))
  2)(= {:a 1} (hash-map :a 1))
  3) (= 2 (count {:a 1 :b 2}))
  4)(= 2 (get {:a 1 :b 2} :b))
  5)(= 1 ({:a 1 :b 2} :a))
  6)(= 1 (:a {:a 1 :b 2}))
  7)(= "Sochi" ({2010 "Vancouver" 2014 "Sochi" 2018 "PyeongChang"} 2014))
  8)(= nil (get {:a 1 :b 2} :c))
  9)(= :key-not-found (get {:a 1 :b 2} :c :key-not-found))
  10)(= true (contains? {:a nil :b nil} :b))
  11)(= false (contains? {:a nil :b nil} :c))
  12)(= {1 "January" 2 "February"} (assoc {1 "January"} 2 "February"))
  13)(= {1 "January"} (dissoc {1 "January" 2 "February"} 2))
  14)(= {:a 1 :b 2 :c 3} (merge {:a 1 :b 2} {:c 3}))
  15)(= {:a 1 :b 2 :c 3} (merge-with + {:a 1 :b 1} {:b 1 :c 3}))
  16)(= (list 2010 2014 2018)
     (sort (keys { 2014 "Sochi" 2018 "PyeongChang" 2010 "Vancouver"})))
  17)(= (list "PyeongChang" "Sochi" "Vancouver")
     (sort (vals {2010 "Vancouver" 2014 "Sochi" 2018 "PyeongChang"})))
  18)(= {:a 2 :b 3}
     (into {}
           (map
            (fn [[k v]] [k (inc v)])
            {:a 1 :b 2}))))
Файл 7
(ns koans.07-functions
  (:require [koan-engine.core :refer :all]))

(defn multiply-by-ten [n]
  (* 10 n))

(defn square [n] (* n n))

  1)(= 81 (square 9))
  2)(= 20 (multiply-by-ten 2))
  3)(= 10 ((fn [n] (* 5 n)) 2))
  4)(= 60 (#(* 15 %) 4))
  5)(= 15 (#(+ %1 %2 %3) 4 5 6))
  6)(= "AACC" (#(str "AA" %2) "bb" "CC"))
  7)(= 9 (((fn [] +)) 4 5))
  8)(= 20 ((fn [f] (f 4 5))
           *))
  9)(= 25 ((fn [f] (f 5))
          (fn [n] (* n n))))
  10)(= 25 ((fn [f] (f 5)) square)))
Файл 8
(ns koans.08-conditionals
  (:require [koan-engine.core :refer :all]))

(defn explain-exercise-velocity [exercise-term]
  (case exercise-term
        :bicycling        "pretty fast"
        :jogging          "not super fast"
        :walking          "not fast at all"
        "is that even exercise?"))
  
1)(= :a (if (false? (= 4 5))
          :a
          :b))
2)(= [] (if (> 4 3)
          []))
3)(= nil (if (nil? 0)
          [:a :b :c]))
4)(= :glory (if (not (empty? ()))
              :doom
              :glory))
5)(let [x 5]
    (= :your-road (cond (= x 0) :road-not-taken
                        (= x 1) :another-road-not-taken
                        :else :your-road)))
6)(= 'doom (if-not (zero? 1)
          'doom
          'more-doom))
7)(= "pretty fast"
     (explain-exercise-velocity :bicycling))
8)(= "is that even exercise?"
     (explain-exercise-velocity :watching-tv)))

Файл 9
(ns koans.09-higher-order-functions
  (:require [koan-engine.core :refer :all]))

1)(= [4 8 12] (map (fn [x] (* 4 x)) [1 2 3]))
2)(= [1 4 9 16 25] (map (fn [x] (* x x)) [1 2 3 4 5]))
3)(= [false false true false false] (map nil? [:a :b nil :c :d]))
4)(= [] (filter (fn [x] false) '(:anything :goes :here)))
5)(= '(:anything :goes :here) (filter (fn [x] true) '(:anything :goes :here)))
6)(= [10 20 30] (filter (fn [x] (< x 40)) [10 20 30 40 50 60 70 80]))
7)(= [10 20 30] (map (fn [x] (* 10 x)) (filter (fn [x] (< x 4)) [1 2 3 4 5 6 7 8])))
8)(= 24 (reduce (fn [a b] (* a b)) [1 2 3 4]))
9)(= 2400 (reduce (fn [a b] (* a b)) 100 [1 2 3 4]))
10)(= "longest" (reduce (fn [a b]
                         (if (< (count a) (count b)) b a))
                       ["which" "word" "is" "longest"])))

Файл 10
(ns koans.10-runtime-polymorphism
  (:require [koan-engine.core :refer :all]))

(defn hello
  ([] "Hello World!")
  ([a] (str "Hello, you silly " a "."))
  ([a & more] (str "Hello to this group: "
                   (apply str
                          (interpose ", " (cons a more)))
                   "!")))

(defmulti diet (fn [x] (:eater x)))
(defmethod diet :herbivore [a] (str (:name a) " eats veggies."))
(defmethod diet :carnivore [a] (str (:name a) " eats animals."))
(defmethod diet :default [a] (str "I don't know what " (:name a) " eats."))

1)(= "Hello World!" (hello))
2)(= "Hello, you silly world." (hello "world"))
3)(= "Hello to this group: Peter, Paul, Mary!" (hello "Peter" "Paul" "Mary"))
4)(= "Bambi eats veggies." (diet {:species "deer" :name "Bambi" :age 1 :eater :herbivore}))
5)(= "Thumper eats veggies." (diet {:species "rabbit" :name "Thumper" :age 1 :eater :herbivore}))
6)(= "Simba eats animals." (diet {:species "lion" :name "Simba" :age 1 :eater :carnivore}))
7)(= "I don't know what Rich Hickey eats." (diet {:name "Rich Hickey"}))

Файл 11
(ns koans.11-lazy-sequences
  (:require [koan-engine.core :refer :all]))

1)(= [1 2 3 4] (range 1 5))
2)(= [0 1 2 3 4] (range 5))
3)(= [0 1 2 3 4 5 6 7 8 9] (take 10 (range 100)))
4)(= [95 96 97 98 99] (drop 95 (range 100)))
5)(= [1 2 4 8 16 32 64 128] (take 8 (iterate (fn [x] (* x 2)) 1)))
6)(= [:a :a :a :a :a :a :a :a :a :a] (repeat 10 :a))
7)(= (repeat 100 "hello") (take 100 (iterate identity "hello")))

Файл 12
(ns koans.12-sequence-comprehensions
  (:require [koan-engine.core :refer :all]))

1)(= [0 1 2 3 4 5] (for [x (range 6)] x))
2)(= '(0 1 4 9 16 25) (map (fn [x] (* x x)) (range 6)) (for [x (range 6)] (* x x)))
3)(= '(1 3 5 7 9) (filter odd? (range 10)) (for [x (range 10) :when (odd? x)] x))
4)(= '(1 9 25 49 81) (map (fn [x] (* x x)) (filter odd? (range 10))) (for [x (range 10) :when (odd? x)] (* x x)))
5)(= [[:top :left] [:top :middle] [:top :right] [:middle :left] [:middle :middle] [:middle :right] [:bottom :left] [:bottom :middle] [:bottom :right]] (for [row [:top :middle :bottom] column [:left :middle :right]] [row column]))

Файл 13
(ns koans.13-creating-functions
  (:require [koan-engine.core :refer :all]))

(defn square [x] (* x x))

1)(= [false false true] (let [not-a-symbol? (complement symbol?)] (map not-a-symbol? [:a 'b "c"])))
2)(= [:wheat "wheat" 'wheat] (let [not-nil? (complement nil?)] (filter not-nil? [nil :wheat nil "wheat" nil 'wheat nil])))
3)(= 20 (let [multiply-by-5 (partial * 5)] (multiply-by-5 4)))
4)(= [:a :b :c :d] (let [ab-adder (partial concat [:a :b])] (ab-adder [:c :d])))
5)(= 25 (let [inc-and-square (comp square inc)] (inc-and-square 4)))
6)(= 8 (let [double-dec (comp dec dec)] (double-dec 10)))
7)(= 99 (let [square-and-dec (comp dec square)] (square-and-dec 10)))

Файл 14
(ns koans.14-recursion
  (:require [koan-engine.core :refer :all]))

(defn is-even? [n]
  (if (= n 0)
    true
    (not (is-even? (dec n)))))

(defn is-even-bigint? [n]
  (loop [n   n
         acc true]
    (if (= n 0)
      acc
      (recur (dec n) (not acc)))))

(defn recursive-reverse [coll]
  (if (empty? coll)
    '()
    (concat (recursive-reverse (rest coll)) [(first coll)])))

(defn factorial [n]
  (if (<= n 1)
    1
    (* n (factorial (dec n)))))

1)(= true (is-even? 0))
2)(= false (is-even? 1))
3)(= false (is-even-bigint? 100003N))
4)(= '(1) (recursive-reverse [1]))
5)(= '(6 5 4 3 2) (recursive-reverse [2 3 4 5 6]))
6)(= 1 (factorial 1))
7)(= 2 (factorial 2))
8)(= 6 (factorial 3))
9)(= 24 (factorial 4))
10)(< 1000000000000000000000000N (factorial 1000N))
11)(< 1000000000000000000000000N (factorial 100003N))

Файл 15
(ns koans.15-destructuring
  (:require [koan-engine.core :refer :all]))

(def test-address
  {:street-address "123 Test Lane"
   :city "Testerville"
   :state "TX"})

1)(= "barfoo" ((fn [[a b]] (str b a)) [:foo :bar]))
2)(= (str "An Oxford comma list of apples, " "oranges, " "and pears.") ((fn [[a b c]] (str "An Oxford comma list of " a ", " b ", and " c ".")) ["apples" "oranges" "pears"]))
3)(= "Rich Hickey aka The Clojurer aka Go Time aka Lambda Guru" (let [[first-name last-name & aliases] (list "Rich" "Hickey" "The Clojurer" "Go Time" "Lambda Guru")] (str first-name " " last-name " aka " (clojure.string/join " aka " aliases))))
4)(= {:original-parts ["Stephen" "Hawking"] :named-parts {:first "Stephen" :last "Hawking"}} (let [[first-name last-name :as full-name] ["Stephen" "Hawking"]] {:original-parts full-name :named-parts {:first first-name :last last-name}}))
5)(= "123 Test Lane, Testerville, TX" (let [{street-address :street-address, city :city, state :state} test-address] (str street-address ", " city ", " state)))
6)(= "123 Test Lane, Testerville, TX" (let [{:keys [street-address city state]} test-address] (str street-address ", " city ", " state)))
7)(= "Test Testerson, 123 Test Lane, Testerville, TX" (let [[first-name last-name] ["Test" "Testerson"] {:keys [street-address city state]} test-address] (str first-name " " last-name ", " street-address ", " city ", " state)))

Файл 16
(ns koans.16-refs
  (:require [koan-engine.core :refer :all]))

(def the-world (ref "hello"))
(def bizarro-world (ref {}))

1)(= "hello" (deref the-world))
2)(= "hello" @the-world)
3)(= "better" (do (dosync (ref-set the-world "better")) @the-world))
4)(= "better!!!" (let [exclamator (fn [x] (str x "!"))] (dosync (alter the-world exclamator) (alter the-world exclamator) (alter the-world exclamator)) @the-world))
5)(= 0 (do (dosync (ref-set the-world 0)) @the-world))
6)(= 20 (do (dosync (alter the-world (fn [x] 20))) @the-world))
7)(= ["Real Jerry" "Bizarro Jerry"] (do (dosync (ref-set the-world {}) (alter the-world assoc :jerry "Real Jerry") (alter bizarro-world assoc :jerry "Bizarro Jerry") [(-> @the-world :jerry) (-> @bizarro-world :jerry)])))

Файл 17
(ns koans.17-atoms
  (:require [koan-engine.core :refer :all]))

(def atomic-clock (atom 0))

1)(= 0 @atomic-clock)
2)(= 1 (do (swap! atomic-clock inc) @atomic-clock))
3)(= 5 (do (swap! atomic-clock (fn [x] 5)) @atomic-clock))
4)(= 20 (do (swap! atomic-clock + 1 2 3 4 5) @atomic-clock))
5)(= 20 (do (compare-and-set! atomic-clock 100 :fin) @atomic-clock))
6)(= :fin (do (compare-and-set! atomic-clock 20 :fin) @atomic-clock))
